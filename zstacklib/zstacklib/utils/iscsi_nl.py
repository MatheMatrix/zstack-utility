#!/usr/bin/env python2
# generated by o1-mini

import struct
import logging
import os
import sys
import re
import socket
import errno

# Configure logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

# Define Netlink message flags
NLM_F_REQUEST = 0x1
NLM_F_ACK = 0x4


# Define iSCSI event types
class IscsiEvent:
    ISCSI_UEVENT_CREATE_SESSION = 11
    ISCSI_UEVENT_DESTROY_SESSION = 12
    ISCSI_UEVENT_CREATE_CONN = 13
    ISCSI_UEVENT_DESTROY_CONN = 14
    ISCSI_UEVENT_BIND_CONN = 15
    ISCSI_UEVENT_SET_PARAM = 16
    ISCSI_UEVENT_START_CONN = 17
    ISCSI_UEVENT_STOP_CONN = 18
    ISCSI_UEVENT_SEND_PDU = 19

    ISCSI_KEVENT_RECV_PDU = 101
    ISCSI_KEVENT_CONN_ERROR = 102
    ISCSI_KEVENT_IF_ERROR = 103
    ISCSI_KEVENT_CREATE_SESSION_RET = 106


# Define iSCSI error types
class IscsiErr:
    ISCSI_OK = 0
    ISCSI_ERR_BASE = 1000
    ISCSI_ERR_DATASN = 1001
    ISCSI_ERR_DATA_OFFSET = 1002
    ISCSI_ERR_MAX_CMDSN = 1003
    ISCSI_ERR_EXP_CMDSN = 1004
    ISCSI_ERR_BAD_OPCODE = 1005
    ISCSI_ERR_DATALEN = 1006
    ISCSI_ERR_AHSLEN = 1007
    ISCSI_ERR_PROTO = 1008
    ISCSI_ERR_LUN = 1009
    ISCSI_ERR_BAD_ITT = 1010
    ISCSI_ERR_CONN_FAILED = 1011
    ISCSI_ERR_R2TSN = 1012
    ISCSI_ERR_SESSION_FAILED = 1013
    ISCSI_ERR_HDR_DGST = 1014
    ISCSI_ERR_DATA_DGST = 1015
    ISCSI_ERR_PARAM_NOT_FOUND = 1016
    ISCSI_ERR_NO_SCSI_CMD = 1017
    ISCSI_ERR_INVALID_HOST = 1018
    ISCSI_ERR_XMIT_FAILED = 1019
    ISCSI_ERR_TCP_CONN_CLOSE = 1020
    ISCSI_ERR_SCSI_EH_SESSION_RST = 1021
    ISCSI_ERR_NOP_TIMEDOUT = 1022


# Define STOP_CONN_RECOVER flag
STOP_CONN_RECOVER = 0x3


def get_netlink_iscsi():
    """
    Extracts the value of NETLINK_ISCSI from system netlink.h header files.
    Searches common include paths and traverses directories if necessary.
    Returns the integer value of NETLINK_ISCSI.
    """
    potential_paths = [
        "/usr/include/linux/netlink.h",
        "/usr/local/include/linux/netlink.h",
        "/usr/src/linux/include/uapi/linux/netlink.h",
    ]

    # Regular expression to match the NETLINK_ISCSI definition
    pattern = re.compile(r'#define\s+NETLINK_ISCSI\s+(\d+)')

    for path in potential_paths:
        if os.path.exists(path):
            try:
                with open(path, 'r') as file:
                    for line in file:
                        match = pattern.match(line)
                        if match:
                            iscsi_value = int(match.group(1))
                            logger.debug("Found NETLINK_ISCSI = %d in %s", iscsi_value, path)
                            return iscsi_value
            except IOError as e:
                logger.warning("Cannot read file %s: %s", path, e)

    # If not found in common paths, traverse include directories
    include_dirs = ["/usr/include", "/usr/local/include"]
    for dir_path in include_dirs:
        for root, dirs, files in os.walk(dir_path):
            if 'netlink.h' in files:
                netlink_path = os.path.join(root, 'netlink.h')
                try:
                    with open(netlink_path, 'r') as file:
                        for line in file:
                            match = pattern.match(line)
                            if match:
                                iscsi_value = int(match.group(1))
                                logger.debug("Found NETLINK_ISCSI = %d in %s", iscsi_value, netlink_path)
                                return iscsi_value
                except IOError as e:
                    logger.warning("Cannot read file %s: %s", netlink_path, e)

    # If still not found, raise an error
    logger.error("NETLINK_ISCSI definition not found in system headers.")
    raise EnvironmentError("NETLINK_ISCSI not found. Ensure kernel headers are installed and accessible.")


def get_iSCSI_transport_handle():
    """
    Retrieves the TransportHandle from the system.
    """
    handle_file = "/sys/class/iscsi_transport/tcp/handle"
    try:
        with open(handle_file, 'r') as f:
            handle_str = f.read().strip()
            logger.debug("Raw Transport Handle string: '%s'", handle_str)
            handle = int(handle_str, 0)  # Automatically detects base (hex or decimal)
            logger.debug("Transport Handle: %d (0x%s)", handle, format(handle, 'x'))
            return handle
    except IOError as e:
        logger.error("Failed to read transport handle from %s: %s", handle_file, e)
        return None
    except ValueError as e:
        logger.error("Invalid transport handle format in %s: %s", handle_file, e)
        return None


def connect_netlink(iscsi_protocol):
    """
    Establishes a Netlink connection using the specified protocol number.
    Returns a socket object.
    """
    try:
        sock = socket.socket(socket.AF_NETLINK, socket.SOCK_RAW, iscsi_protocol)
    except socket.error as e:
        logger.error("Failed to create netlink socket: %s", e)
        return None

    pid = os.getpid()
    groups = 0  # Multicast groups, set to 0 for unicast

    try:
        sock.bind((pid, groups))
    except socket.error as e:
        logger.error("Failed to bind netlink socket: %s", e)
        sock.close()
        return None

    logger.debug("Successfully connected to Netlink with pid=%d, groups=%d", pid, groups)
    return sock


def send_netlink_message(sock, event_type, payload):
    """
    Sends a Netlink message and waits for a response.
    Returns the response payload or an error message.
    """
    pid = os.getpid()
    seq = 0  # Use sequence number 0 to align with response

    # Construct Netlink message header
    nlmsg_len = 16 + len(payload)
    nlmsg_type = event_type
    nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK  # Set request and acknowledgment flags
    nlmsg_seq = seq
    nlmsg_pid = pid

    nlmsg_header = struct.pack('=IHHII', nlmsg_len, nlmsg_type, nlmsg_flags, nlmsg_seq, nlmsg_pid)
    message = nlmsg_header + payload

    # Send the message
    try:
        sock.send(message)
        logger.debug("Sent Netlink message: type=%d, seq=%d, pid=%d, payload_len=%d",
                     nlmsg_type, nlmsg_seq, nlmsg_pid, len(payload))
    except socket.error as e:
        logger.error("Failed to send Netlink message: %s", e)
        return "Failed to send Netlink message: {}".format(e)

    # Receive the response
    try:
        # Set a timeout for receiving
        sock.settimeout(5)  # 5 seconds timeout
        while True:
            try:
                response = sock.recv(65535)  # Maximum Netlink message size
                if not response:
                    break
            except socket.timeout:
                logger.error("Netlink receive timed out.")
                return "Netlink receive timed out."

            # Parse the response
            if len(response) < 16:
                logger.error("Received message too short.")
                continue

            # Unpack Netlink header
            resp_nlmsg_len, resp_nlmsg_type, resp_nlmsg_flags, resp_nlmsg_seq, resp_nlmsg_pid = struct.unpack('=IHHII',
                                                                                                              response[
                                                                                                              :16])
            resp_payload = response[16:]

            logger.debug("Received Netlink response: type=%d, seq=%d, pid=%d, payload_len=%d",
                         resp_nlmsg_type, resp_nlmsg_seq, resp_nlmsg_pid, len(resp_payload))

            # Dump raw payload in hex for debugging
            logger.debug("Received payload in hex: %s", resp_payload.encode('hex'))

            # Check sequence number
            if resp_nlmsg_seq != seq:
                logger.debug("Ignoring message with seq=%d", resp_nlmsg_seq)
                continue

            # Note: Return the entire payload for further parsing
            return resp_payload

    except socket.timeout:
        logger.error("Netlink receive timed out.")
        return "Netlink receive timed out."
    except socket.error as e:
        logger.error("Error receiving Netlink response: %s", e)
        return "Error receiving Netlink response: {}".format(e)


def stop_connection(sock, transport_handle, sid, cid, conn_handle):
    """
    Stops an iSCSI connection by sending ISCSI_UEVENT_STOP_CONN.
    """
    # Construct payload
    # struct:
    # uint32_t Type
    # uint32_t IfError
    # uint64_t TransportHandle
    # uint32_t Sid
    # uint32_t Cid
    # uint64_t ConnHandle
    # uint32_t Flag
    padding = b'\x00' * 36  # 2 uint32_t padding
    payload = struct.pack('=IIQIIQI',
                          IscsiEvent.ISCSI_UEVENT_STOP_CONN,
                          0,  # IfError
                          transport_handle,
                          sid,
                          cid,
                          conn_handle,
                          STOP_CONN_RECOVER) + padding + struct.pack('=I', IscsiErr.ISCSI_OK)
    # Send the message
    response = send_netlink_message(sock, IscsiEvent.ISCSI_UEVENT_STOP_CONN, payload)

    if response:
        if len(response) >= 44:
            # Extract IfError (bytes 4-7)
            if_error, = struct.unpack('=i', response[4:8])
            # Extract Ret (bytes 40-43)
            ret_code, = struct.unpack('=I', response[40:44])

            logger.debug("Parsed IfError: %d, Ret: %d", if_error, ret_code)

            if if_error != 0:
                error_message = "Interface Error: {}".format(if_error)
                logger.error(error_message)
                return error_message
            elif ret_code != IscsiErr.ISCSI_OK:
                error_message = "Error stopping connection: {}".format(ret_code)
                logger.error(error_message)
                return error_message
            else:
                success_message = "Successfully stopped connection SID: %d, CID: %d" % (sid, cid)
                logger.info(success_message)
                return None
        else:
            logger.error("Invalid response payload length for stop_connection.")
            return "Invalid response payload length."
    else:
        # Assuming success if no response
        logger.info("Successfully stopped connection SID: %d, CID: %d", sid, cid)
        return None


def destroy_connection(sock, transport_handle, sid, cid):
    """
    Destroys an iSCSI connection by sending ISCSI_UEVENT_DESTROY_CONN.
    """
    # Construct payload
    # struct:
    # uint32_t Type
    # uint32_t IfError
    # uint64_t TransportHandle
    # uint32_t Sid
    # uint32_t Cid
    # uint8_t Padding (16 bytes)
    # uint32_t Ret (should be ISCSI_OK)
    padding = b'\x00' * 28
    payload = struct.pack('=IIQII',
                          IscsiEvent.ISCSI_UEVENT_DESTROY_CONN,
                          0,  # IfError
                          transport_handle,
                          sid,
                          cid) + padding + struct.pack('=I', IscsiErr.ISCSI_OK)
    # Send the message
    response = send_netlink_message(sock, IscsiEvent.ISCSI_UEVENT_DESTROY_CONN, payload)

    if response:
        if len(response) >= 44:
            # Extract IfError (bytes 4-7)
            if_error, = struct.unpack('=i', response[4:8])
            # Extract Ret (bytes 40-43)
            ret_code, = struct.unpack('=I', response[40:44])

            logger.debug("Parsed IfError: %d, Ret: %d", if_error, ret_code)

            if if_error != 0:
                error_message = "Interface Error: {}".format(if_error)
                logger.error(error_message)
                return error_message
            elif ret_code != IscsiErr.ISCSI_OK:
                error_message = "Error destroying connection: {}".format(ret_code)
                logger.error(error_message)
                return error_message
            else:
                success_message = "Successfully destroyed connection SID: %d, CID: %d" % (sid, cid)
                logger.info(success_message)
                return None
        else:
            logger.error("Invalid response payload length for destroy_connection.")
            return "Invalid response payload length."
    else:
        # Assuming success if no response
        logger.info("Successfully destroyed connection SID: %d, CID: %d", sid, cid)
        return None


def destroy_session(sock, transport_handle, sid):
    """
    Destroys an iSCSI session by sending ISCSI_UEVENT_DESTROY_SESSION.
    """
    # Construct payload
    padding = b'\x00' * 32  # 5 uint32_t padding
    payload = struct.pack('=IIQ',
                          IscsiEvent.ISCSI_UEVENT_DESTROY_SESSION,
                          0,  # IfError
                          transport_handle) + struct.pack('=I', sid) + padding + struct.pack('=I', IscsiErr.ISCSI_OK)
    # Send the message
    response = send_netlink_message(sock, IscsiEvent.ISCSI_UEVENT_DESTROY_SESSION, payload)

    if response:
        if len(response) >= 44:
            # Extract IfError (bytes 4-7)
            if_error, = struct.unpack('=i', response[4:8])
            # Extract Ret (bytes 40-43)
            ret_code, = struct.unpack('=I', response[40:44])

            logger.debug("Parsed IfError: %d, Ret: %d", if_error, ret_code)

            if if_error != 0:
                error_message = "Interface Error: {}".format(if_error)
                logger.error(error_message)
                return error_message
            elif ret_code != IscsiErr.ISCSI_OK:
                error_message = "Error destroying session: {}".format(ret_code)
                logger.error(error_message)
                return error_message
            else:
                success_message = "Successfully destroyed session SID: {}".format(sid)
                logger.info(success_message)
                return None
        else:
            logger.error("Invalid response payload length for destroy_session.")
            return "Invalid response payload length."
    else:
        # Assuming success if no response
        logger.info("Successfully destroyed session SID: {}".format(sid))
        return None



def clean_session(sid, cid=0, conn_handle=0):
    # Get Transport Handle
    transport_handle = get_iSCSI_transport_handle()
    if transport_handle is None:
        print("Failed to get TransportHandle.")
        sys.exit(1)

    # Get NETLINK_ISCSI protocol number
    try:
        iscsi_protocol = get_netlink_iscsi()
    except EnvironmentError as e:
        print(e)
        sys.exit(1)

    # Connect to Netlink
    sock = connect_netlink(iscsi_protocol)
    if sock is None:
        print("Failed to connect to Netlink.")
        sys.exit(1)

    errors = False

    ret = stop_connection(sock, transport_handle, sid, cid, conn_handle)
    if ret:
        print("Error stopping connection: {}".format(ret))
        errors = True

    # Destroy Connection
    ret = destroy_connection(sock, transport_handle, sid, cid)
    if ret:
        print("Error destroying connection: {}".format(ret))
        errors = True

    # Destroy Session
    ret = destroy_session(sock, transport_handle, sid)
    if ret:
        print("Error destroying session: {}".format(ret))
        errors = True

    # Close the socket
    sock.close()
    return errors


def main():
    """
    Main function to parse command-line arguments and perform iSCSI operations.
    """
    if len(sys.argv) not in [2, 4]:
        print("Usage:")
        print("  {} <SID>".format(sys.argv[0]))
        print("  {} <SID> <CID> <ConnHandle>".format(sys.argv[0]))
        print("Example:")
        print("  {} 1".format(sys.argv[0]))
        print("  {} 1 2 123456789".format(sys.argv[0]))
        sys.exit(1)

    try:
        sid = int(sys.argv[1])
        if len(sys.argv) == 4:
            cid = int(sys.argv[2])
            conn_handle = int(sys.argv[3])
        else:
            cid = 0
            conn_handle = 0
    except ValueError:
        print("Invalid arguments. SID, CID, and ConnHandle must be integers.")
        sys.exit(1)

    errors = clean_session(sid, cid, conn_handle)
    if errors:
        sys.exit(1)
    else:
        sys.exit(0)


if __name__ == "__main__":
    main()